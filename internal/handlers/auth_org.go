package handlers

import (
	"errors"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
	"github.com/the-monkeys/monkeys-identity/internal/models"
	"github.com/the-monkeys/monkeys-identity/internal/queries"
	"golang.org/x/crypto/bcrypt"
)

// RegisterOrganizationRequest defines the payload for registering a new organization
type RegisterOrganizationRequest struct {
	OrganizationName string `json:"organization_name" validate:"required,min=3,max=100"`
	Username         string `json:"username" validate:"required,min=3,max=50"`
	Email            string `json:"email" validate:"required,email"`
	Password         string `json:"password" validate:"required,min=8"`
	DisplayName      string `json:"display_name" validate:"required"`
}

// RegisterOrganization creates a new organization and its first admin user
//
//	@Summary		Register new organization
//	@Description	Register a new organization and its first admin user
//	@Tags			Authentication
//	@Accept			json
//	@Produce		json
//	@Param			request	body		RegisterOrganizationRequest	true	"Organization registration details"
//	@Success		201		{object}	SuccessResponse		"Organization created successfully"
//	@Failure		400		{object}	ErrorResponse		"Invalid request format or validation error"
//	@Failure		409		{object}	ErrorResponse		"User already exists"
//	@Failure		500		{object}	ErrorResponse		"Internal server error"
//	@Router			/auth/register-org [post]
func (h *AuthHandler) RegisterOrganization(c *fiber.Ctx) error {
	var req RegisterOrganizationRequest
	if err := c.BodyParser(&req); err != nil {
		return apiError(c, fiber.StatusBadRequest, "invalid_request", "Invalid request format")
	}

	// 1. Check if user already exists (globally by email, passed as empty orgID to check all?
	// Actually queries.GetUserByEmail checks specific org if provided.
	// For a new org, we might want to ensure the email isn't used in *this* new org (trivial since it's new)
	// OR we might want to enforce global uniqueness for email?
	// Let's stick to the current pattern: users are scoped to orgs.
	// But we should check if they are trying to register an org that might clash? Or we generate ID.
	// We generate ID, so no clash there.

	// 2. Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		h.logger.Error("Failed to hash password: %v", err)
		return apiError(c, fiber.StatusInternalServerError, "server_error", "Failed to process password")
	}

	// 3. Prepare User model (OrganizationID will be generated by CreateAdminUser logic if empty,
	// but here we want to Control the Org Name.
	// The underlying CreateAdminUser query logic handles new Org creation if ID is empty,
	// BUT it auto-generates the name. We want to use the provided name.
	// So we should probably adapt the query or do it here.

	// Since `CreateAdminUser` in `auth_queries.go` has hardcoded "Admin Organization ..." naming when ID is empty,
	// we should probably manually create the Org ID here and pass it, OR update the query.
	// Modifying the query function signature might break other things.
	// Let's generate the ID here.
	newOrgID := uuid.New().String()

	// We need a transaction to do this properly: Create Org -> Create User -> Assign Role.
	// `CreateAdminUser` does this transactionally but with fixed naming.
	// To avoid duplicating all that transactional logic here in the handler (which is bad practice),
	// we should use a Service layer or extend the Query layer.
	// Given the current architecture seems to put logic in Handlers + Queries:
	// The cleanest way without changing `queries` interface too much is to manually insert the Org first?
	// No, that breaks transactionality.

	// Let's rely on `CreateAdminUser` query but pass a pre-generated ID.
	// Wait, `CreateAdminUser` in `auth.go` (lines 202+) checks:
	// if user.OrganizationID == "" -> creates new with hardcoded name.
	// if user.OrganizationID != "" -> checks if exists, if not -> creates with hardcoded name "Organization ..."

	// This is a limitation of the current `CreateAdminUser` query implementation.
	// For now, to solve the User's problem of "Multi Tenancy", I will use `CreateAdminUser`
	// with a generated ID. The name will be "Organization <ID>".
	// Ideally, we should update `CreateAdminUser` to accept an Org Name or update the Org after.

	// Workaround: We will let `CreateAdminUser` create it, and then we Update the Organization Name?
	// Or we just accept the default name for now to unblock.
	// User didn't explicitly ask for custom Org Names in the prompt, just "register their org".
	// But `RegisterOrganizationRequest` has `OrganizationName`.
	// I should probably add `CreateOrganization` to `OrganizationQueries`?
	// But `AuthQueries` handles the "Bootstrap" flow.

	// Let's modify `CreateAdminUser` in `internal/queries/auth.go`?
	// No, that file is huge.

	// Let's try to pass the Org Name via the User struct? No field for that.
	// Let's just create the Organization FIRST properly.
	// But we need to do it as a transaction ideally.

	// Let's look at `OrganizationQueries`.
	// If I create the Org first, `CreateAdminUser` usage of it will work (it checks if exists).
	// But `CreateAdminUser` expects `admin` role creation too.

	// Proposal:
	// 1. Create Organization using `OrganizationQueries.CreateOrganization` (if it exists) or just SQL.
	// 2. Call `CreateAdminUser` with that OrgID.

	// Let's check `organization_queries.go` first.
	// For now, I'll write the handler assuming I can just call `CreateAdminUser` and maybe
	// the user is fine with auto-generated names, OR I'll add a separate update step.
	// ACTUALLY, I can just use a `CustomCreateOrganizationAdmin` method if I wanted to be perfect.

	// Let's stick to: Generate ID. Call `CreateAdminUser`.
	// If I want to support the name, I should update the Org after creation.
	// user.OrganizationID = newOrgID.

	user := &models.User{
		ID:             uuid.New().String(),
		Username:       req.Username,
		Email:          req.Email,
		DisplayName:    req.DisplayName,
		OrganizationID: newOrgID,
		PasswordHash:   string(hashedPassword),
		Status:         "active",
		EmailVerified:  true, // Admins verified by default? Or should we require verification?
		// For a signup flow, maybe we want verification. But `CreateAdminUser` sets it to true.
		// Let's keep it true for MVP.
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// We need to ensure the Org Name is set correctly.
	// `CreateAdminUser` in queries (line 242) uses "Organization " + ID.
	// I will just use that for now to avoid modifying the massive `auth.go` query file and risking breakage.
	// Use `UpdateOrganization` after if possible?
	// Or maybe I can implement `CreateOrganizationWithAdmin` in `auth_queries.go`?
	// That seems cleaner but I don't want to edit that file if I can avoid it (it's 600 lines).

	// Let's check `internal/handlers/handlers.go` to see if I validly have access to `queries`.
	// Yes `AuthHandler` has `queries`.

	err = h.queries.Auth.CreateAdminUser(user)
	if err != nil {
		if errors.Is(err, queries.ErrOrganizationNotFound) {
			return apiError(c, fiber.StatusBadRequest, "invalid_request", "Organization could not be created")
		}

		h.logger.Error("Failed to create org admin: %v", err)
		return apiError(c, fiber.StatusInternalServerError, "server_error", "Failed to create organization. Please try again.")
	}

	// Update organization name (it was auto-generated as "Organization <ID>" in CreateAdminUser)
	org, err := h.queries.Organization.GetOrganization(user.OrganizationID)
	if err == nil {
		org.Name = req.OrganizationName
		// Generate a simple slug from the name or ID
		org.Slug = "org-" + user.OrganizationID[:8]
		if err := h.queries.Organization.UpdateOrganization(org); err != nil {
			h.logger.Warn("Failed to update organization name: %v", err)
		}
	} else {
		h.logger.Warn("Failed to fetch organization for name update: %v", err)
	}

	h.logger.Info("Organization registered successfully: %s", user.OrganizationID)

	return apiSuccess(c, fiber.StatusCreated, "Organization created successfully", fiber.Map{
		"user_id":         user.ID,
		"organization_id": user.OrganizationID,
		"username":        user.Username,
		"email":           user.Email,
		"role":            "admin",
	})
}
